# JARVIS - 핵심 기능 상세 스펙

## 1. 입력 엔진 (Input Engine)

### 1.1 텍스트 파서

**목적:** 비정형 구어체 텍스트를 구조화된 데이터로 변환

**처리 단계:**

```
원본: "레전드라는 영화봄 톰하디 개멋있음 그리고 저녁에 을지로 크로플 먹음"
                    │
                    ▼
정규화: "레전드라는 영화를 봤다. 톰하디가 매우 멋있었다.
        그리고 저녁에 을지로에서 크로플을 먹었다."
                    │
                    ▼
토픽 분리:
  Segment 1: "레전드라는 영화를 봤다. 톰하디가 매우 멋있었다."
  Segment 2: "저녁에 을지로에서 크로플을 먹었다."
```

**LLM 프롬프트 전략:**

```
시스템: 너는 비정형 텍스트에서 토픽을 추출하는 전문가야.
사용자 입력을 분석해서 다음을 추출해:

1. 토픽 분리: 서로 다른 주제는 별도 토픽으로
2. 엔티티 추출: 사람, 작품, 장소, 음식, 기술 등
3. 토픽 유형 분류: MOVIE, FOOD, TECH, EXERCISE, BOOK, MUSIC, PLACE, IDEA, etc.
4. 감정/의견 추출: 사용자의 감상이나 평가
5. 시간 정보: 언제의 일인지 (오늘, 어제, 지난주 등)

출력 형식:
{
  "topics": [
    {
      "type": "MOVIE",
      "title": "레전드",
      "entities": ["톰 하디"],
      "sentiment": "positive",
      "opinion": "톰하디 개멋있음",
      "time_context": "today",
      "confidence": 0.95
    }
  ]
}
```

### 1.2 복합 입력 분리기

하나의 긴 텍스트에서 여러 주제를 자동 분리하는 모듈.

**분리 신호:**
- 접속사: "그리고", "아 그리고", "또", "참"
- 주제 전환: 완전히 다른 도메인의 엔티티 등장
- 시간 전환: "오전에", "저녁에", "그 다음에"

**엣지 케이스 처리:**
```
# 케이스 1: 하나의 토픽인데 길게 쓴 경우
"레전드 영화 봤는데 톰하디가 쌍둥이를 연기하는데
 진짜 한명이 연기한거 맞나 싶을정도로 다르고
 슈트핏이 진짜 미쳤음"
→ 하나의 토픽 (영화-레전드)으로 유지

# 케이스 2: 관련 있지만 다른 토픽
"레전드 영화 보고 나와서 근처 바에서 칵테일 마심"
→ 두 개의 토픽이지만 관계(연속 이벤트)를 유지
```

---

## 2. 클러스터링 엔진 (Clustering Engine)

### 2.1 클러스터 매칭 알고리즘

```
새 Entry 입력
    │
    ▼
기존 클러스터들의 centroid embedding과 비교
    │
    ├── 유사도 > 0.85 → 기존 클러스터에 추가
    │                    centroid 재계산
    │
    ├── 0.6 < 유사도 < 0.85 → 사용자에게 확인
    │   "이 기록을 [영화] 클러스터에 넣을까요?"
    │
    └── 유사도 < 0.6 → 새 클러스터 생성
        부모 클러스터 후보 탐색
```

### 2.2 클러스터 자동 세분화

```python
# 의사 코드
def check_subdivision(cluster):
    if cluster.entry_count >= 3:
        # 클러스터 내 항목들의 하위 그룹 탐색
        sub_groups = find_sub_clusters(cluster.entries)

        for group in sub_groups:
            if group.size >= 2 and group.coherence > 0.7:
                # 하위 클러스터 생성 제안
                suggest_subdivision(cluster, group)
                # 예: "영화" → "영화 > 느와르", "영화 > SF"
```

### 2.3 클러스터 계층 구조

```
Level 0 (자동): 대분류
  - 엔터테인먼트, 라이프, 개발, 학습, 아이디어

Level 1 (자동): 중분류
  - 엔터테인먼트 > 영화, 음악, 드라마, 게임
  - 라이프 > 맛집, 운동, 여행

Level 2 (자동/3개 이상 시): 소분류
  - 영화 > 느와르, SF, 로맨스
  - 운동 > 웨이트, 러닝, 수영

Level 3+ (선택적): 더 세분화
  - 웨이트 > 가슴, 등, 하체
```

---

## 3. 정보 보강 엔진 (Enrichment Engine)

### 3.1 토픽 유형별 검색 전략

#### 영화 (MOVIE)
```
검색 소스: TMDB API, 네이버 영화, Google
수집 정보:
  - 기본: 제목, 원제, 개봉년도, 감독, 출연진
  - 상세: 장르, 줄거리, 러닝타임, 관람등급
  - 미디어: 포스터 이미지, 예고편 링크
  - 평점: IMDB, 로튼토마토, 관객 평점
  - 메타: 수상 이력, 박스오피스
```

#### 음식/맛집 (FOOD)
```
검색 소스: 네이버 지도, Google Maps, 카카오맵
수집 정보:
  - 기본: 가게명, 주소, 전화번호
  - 상세: 메뉴, 가격대, 영업시간
  - 미디어: 사진, 지도 위치
  - 평점: 네이버/카카오 리뷰 평점
  - 메타: 주차 가능 여부, 예약 필요 여부
```

#### 책 (BOOK)
```
검색 소스: 교보문고 API, Google Books, 알라딘
수집 정보:
  - 기본: 제목, 저자, 출판사, 출간일
  - 상세: 장르, 줄거리, 페이지수
  - 미디어: 표지 이미지
  - 메타: ISBN, 베스트셀러 순위
```

#### 개발/기술 (TECH)
```
검색 소스: MDN, Stack Overflow, 공식 문서
수집 정보:
  - 기본: 기술명, 버전, 카테고리
  - 상세: 공식 문서 링크, 예제 코드
  - 메타: 관련 라이브러리, 대안 기술
```

### 3.2 검색 실패 처리

```
검색 실패 시:
1. 다른 검색 소스로 폴백
2. 부분 정보라도 수집
3. 정보 없으면 사용자에게 알림
   "영화 '레전드' 정보를 찾지 못했어요.
    혹시 다른 이름으로 알려진 영화인가요?"
4. 사용자가 직접 정보 입력 가능
```

---

## 4. 감상평 구체화 엔진 (Opinion Expansion Engine)

### 4.1 구체화 전략

```
입력 분석:
1. 감성 분석: 긍정/부정/중립
2. 대상 파악: 무엇에 대한 감상인지
3. 맥락 수집: 작품 정보 + 일반 상식
4. 추론: 사용자가 아마 이런 점을 느꼈을 것

프롬프트 전략:
"사용자가 영화 '레전드(2015)'를 보고 '톰하디 개멋있음'이라고 했다.
이 영화에서 톰 하디는 크레이 쌍둥이 역할을 맡았고, 갱스터 영화 특성상
슈트를 입는 장면이 많다.

'멋있다'라는 감상을 구체화해줘.
단, 과도한 추측은 하지 말고, 영화의 실제 장면/특성에 기반해서.
문체는 사용자의 원래 톤을 유지하되 조금 더 구체적으로."
```

### 4.2 구체화 레벨

```
Level 1 (안전): 명확한 사실 기반 확장
  원본: "톰하디 개멋있음"
  확장: "톰 하디의 연기가 인상적이었다."

Level 2 (추론): 작품 맥락 기반 추론
  원본: "톰하디 개멋있음"
  확장: "톰 하디의 슈트핏과 1인 2역 연기가 인상적이었다."

Level 3 (심화): 감성적 추론 포함
  원본: "톰하디 개멋있음"
  확장: "톰 하디의 슈트핏과 담배 피우는 장면에서 느껴지는
         올드스쿨 갱스터 감성이 인상적이었다. 한 배우가
         쌍둥이를 연기하면서 완전히 다른 카리스마를 보여주는
         게 놀라웠다."

→ 기본: Level 2 적용
→ 사용자 설정으로 레벨 조절 가능
```

### 4.3 사용자 피드백 루프

```
AI 구체화 결과 제시
    │
    ├── [맞아] → 확정, 향후 추론 신뢰도 ↑
    │
    ├── [아니야] → 원본만 유지, 추론 패턴 학습
    │
    └── [수정] → 사용자 수정본 반영, 가장 좋은 학습 데이터

→ 피드백이 쌓이면 사용자별 "추론 성향" 학습
   예: "이 사용자는 영화 감상에서 '연기력'보다 '비주얼'에 더 반응"
```

---

## 5. 시맨틱 검색 엔진 (Semantic Search Engine)

### 5.1 검색 유형

#### 타입 A: 직접 검색
```
"레전드 영화" → 키워드 매칭으로 바로 찾음
```

#### 타입 B: 속성 기반 검색
```
"톰하디 나오는 영화" → 엔티티 관계 기반 검색
```

#### 타입 C: 회상형 검색 (핵심 차별점)
```
"아 그때 무슨 느와르영환데 슈트핏이 멋있는 영화"
→ 시맨틱 유사도 + 감상평 내용 + 태그 종합 검색
```

#### 타입 D: 감정 기반 검색
```
"진짜 감동받은 영화" → 감성 분석 기반 필터링
```

#### 타입 E: 시간 기반 검색
```
"지난달에 본 영화" → 시간 필터 + 카테고리 필터
```

### 5.2 임베딩 전략

각 Entry에 대해 **복합 임베딩**을 생성:

```
Entry 임베딩 = weighted_combine(
  content_embedding,      // 원본 텍스트 (0.3)
  enriched_embedding,     // 보강된 정보 (0.2)
  opinion_embedding,      // 감상평 (원본 + AI) (0.3)
  tag_embedding,          // 태그 (0.1)
  cluster_embedding       // 클러스터 맥락 (0.1)
)
```

### 5.3 검색 결과 내러티브

단순한 결과 목록이 아닌, **회상 내러티브** 형태로 제공:

```
검색: "슈트핏 멋있는 느와르"

결과:
"2026년 2월 24일에 영화 '레전드'를 보셨습니다.
 그때 '톰하디 개멋있음'이라고 하셨고,
 톰 하디의 슈트핏과 느와르 분위기가 특히
 인상적이셨던 것 같아요.

 이거 찾으시는 건가요?"
```

---

## 6. 사용자 학습 엔진 (User Learning Engine)

### 6.1 취향 프로필 자동 구축

```
기록이 쌓이면서 사용자 프로필이 자동으로 구축됨:

취향 프로필:
{
  "movie": {
    "preferred_genres": ["느와르", "범죄", "SF"],
    "important_factors": ["연기력", "비주얼", "OST"],
    "favorite_actors": ["톰 하디", "..."],
    "watch_frequency": "주 1-2회"
  },
  "food": {
    "preferred_types": ["카페", "양식"],
    "important_factors": ["분위기", "맛"],
    "frequent_areas": ["을지로", "성수"]
  }
}
```

### 6.2 연관 기억 네트워크

```
"레전드" ─── 톰 하디 ─── "다크나이트 라이즈"
    │                          │
    │                          │
 느와르 ────── 슈트핏 ─── "대부"
    │
    │
 범죄영화 ─── "굿펠라즈"

→ 연관 기억을 통해 더 풍부한 검색 & 추천 가능
```
